
<div><strong>Arrow functions</strong>
  <pre>const square = x => x * x;</pre>

  <p>This code defines the function <strong>square</strong>
    using arrow notation. It is about the same as

  <pre>function square (x) { return x * x; }</pre>

  <p>An arrow function is simpler, especially with functions that just return a value,
    and does not re-bind the special variable
    <strong>this</strong>. 
  </p>
</div>

<div><strong>Method definitions in objects</strong>
  <pre>const obj = {
  <strong>foo() {
    return 'bar';
  }</strong>
}</pre>

  <p>This code defines the method <strong>obj.foo()</strong>. It is the same
    as the following, but briefer:</p>

  <pre>const obj = {
  <strong>foo: function foo() {
    return 'bar';
  }</strong>
}</pre>
</div>

<div>
  <strong>Destructuring object assignment</strong>
  <pre>const Hello = <strong>({name})</strong> => &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;</pre>

  <p>This code is using destructuring object assignment. It is the same as this:</p>

  <pre>const Hello = <strong>(props) => {
  const name = props.name;</strong>
  &lt;h1&gt;Hello, {name}&lt;/h1&gt;;
}</pre>
</div>

<div><strong>Destructuring array assignment</strong>
<pre>const [state, setState] = useState(initialState);</pre>

<p>This code is using destructuring array assignment. It is shorthand for:</p>

<pre>const parts = useState(initialState);
const state = parts[0];
const setState = parts[1];</pre>
</div>

<div><strong>Destructuring import</strong>
  <pre>import { useState } from 'react';</pre>

  <p>This is importing just the name <strong>useState</strong> from the React module</p>
</div>

<div><strong>Functional Components</strong>
  <pre>const Welcome = (props) => &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;</pre>

  <p>This defines the React component <strong>Welcome</strong> as
    a simple JavaScript function that calls <strong>render()</strong>.
    This is the simplest way to define components with no local state, constructor, or lifecycle
    methods.
  </p>
</div>

<div><strong>React.Component subclasses</strong>
  <pre>class Welcome extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}</pre>

  <p>This defines the component <strong>Welcome</strong> as
    a JavaScript subclass. The class definition can include
    a constructor, local state variables, and React
    lifecycle methods. See <a href="#react-classes">React class components</a>
    for more information.
  </p>
</div>

<div><strong>Export</strong>
  <pre>export const loadCart = (cartProducts) => ...</pre>

  <p>This exports <strong>loadCart()</strong> from a module, so that 
    it can be imported in another module, like this</p>

  <pre>import { loadCart } from '../../store/actions/floatCartActions'</pre>
</div>

<div><strong>Export default</strong>
  <pre>export default class Welcome extends React.Component {
...
}</pre>

  <p>This defines <strong>Welcome</strong> as the default name exported
    from a module, so that it can be imported in another file like this</p>

  <pre>import Welcome from './Welcome'</pre>
</div>

<div>
  <strong>const variable declarations</strong>
  <pre>const weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
<span style="color:red">weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];  // illegal</span>
  </pre>

  <p>This declares <strong>weekdays</strong> as a local variable with block scope
    that can't be reassigned a new value. Most variables should be declared this
    way. Such code is easier to analyze and maintain.
  </p>

  <p>
    Note a structure stored in a <strong>const</strong> variable can be modified, e.g.,
  </p>

  <pre>weekdays.unshift(weekdays.pop()) // weekdays is now ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']</pre>
</div>

<div>
  <strong>let declarations</strong>
  <pre>const getItem = (key, items) => {
  <strong>let item = items.find(item => item.key === key);</strong>
  if (!item) {
    item = { key };
    items.push(item);
  }
  return item;
}</pre>

  <p>This declares a local variable <strong>item</strong> with block scope that can be reassigned. 
    <strong>let</strong> is preferred over <strong>var</strong> because it has
    narrower scope.
  </p>
</div>